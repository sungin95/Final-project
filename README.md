# 🌳 Plan T

---

> 사이트 바로가기
>
> Domain : [Plan T](http://plan-t.site/)
>
> ![logo.png](assets/logo.png)

<br>

## ✔ What is Plan T?

---

- Todo를 중점으로 한 개인 일정 관리 서비스와 스터디 커뮤니티를 통해 스터디 구성원들 간 공통 목표 Todo를 공유하는 웹 서비스

- 플랜을 짜다 의 Plan 과 식물의 Plant 를 합쳐 나를 키우는 계획이라는 뜻을 가지고 있다

- 프로젝트 기간 11.25 ~ 12.14
  
  | 구분       | 기간            | 활동              |
  |:--------:|:-------------:|:---------------:|
  | 프로젝트 기획  | 11.25 ~ 11.28 | 주제 선정 및 프로젝트 기획 |
  | 기본 기능 구현 | 11.29 ~ 12.13 | 기능 구현           |
  | 배포       | 12.14         | 배포              |
  | 문서 작성    | 12.13 ~ 12.14 | PPT , 기획서 정리    |
  | 프로젝트 발표  | 12.15         | 프로젝트 발표         |

<br>

## ✔ Plan T의 탄생 배경

---

- 사용해본 Todo 어플이나 스터디 어플 같은 경우에 개별적으로 일정을 관리해야 하기 때문에 일괄적으로 관리할 수 있는 서비스가 필요하다

- 기존의 플래너를 이용하지 않던 사용자의 유입을 위해서 필요한 기능들만 심플하게 구현한다

<br>

## ✔ 기술스택

* Version Control and Messenger

   <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white"><img src="https://img.shields.io/badge/Notion-000000?style=for-the-badge&logo=Notion&logoColor=white"> <img src="https://img.shields.io/badge/Discord-5865F2?style=for-the-badge&logo=Discord&logoColor=white">

* Backend

  <img src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=Django&logoColor=white">

* Frontend

  <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=HTML5&logoColor=white"> <img src="https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=CSS3&logoColor=white"> <img src="https://img.shields.io/badge/Javascript-F7DF1E?style=for-the-badge&logo=Javascript&logoColor=white"><img src="https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge&logo=Axios&logoColor=white">

* Infra

  <img src="https://img.shields.io/badge/Amazon AWS-232F3E?style=for-the-badge&logo=Amazon AWS&logoColor=white"> <img src="https://img.shields.io/badge/Ubuntu-E95420?style=for-the-badge&logo=ubuntu&logoColor=white"> <img src="https://img.shields.io/badge/nginx-%23009639.svg?style=for-the-badge&logo=nginx&logoColor=white">

<br>

## ✔ 프로젝트 참여자

---

|                                                                             | 이름  | 팀   | 역할  | 깃허브 주소                         |
|:---------------------------------------------------------------------------:|:---:|:---:|:---:| ------------------------------ |
| <img src="assets/2022-12-14-17-15-23-image.png" title="" alt="" width="56"> | 오채현 | 팀원  | 프론트 | https://github.com/chaehyun-oh |
| <img src="assets/2022-12-14-17-20-50-image.png" title="" alt="" width="56"> | 류진숙 | 팀원  | 프론트 | https://github.com/wdahlia     |
| <img title="" src="assets/2022-12-14-17-16-59-image.png" alt="" width="61"> | 이동근 | 팀원  | 백   | https://github.com/qlghwp123   |
| <img title="" src="assets/2022-12-14-17-18-28-image.png" alt="" width="53"> | 이성인 | 팀원  | 백   | https://github.com/sungin95    |
| <img src="assets/2022-12-14-17-23-03-image.png" title="" alt="" width="61"> | 이은진 | 팀원  | 백   | https://github.com/OIIUOI      |

<br>

## ✔ 주요 기능

---

### 목차

* User
  * 사용자 관리
  * 로그인 / 로그아웃
  * 회원가입 / 탈퇴
  * 프로필 – 마이페이지
* Todo
  * Todo 생성, 조회, 수정, 삭제 (CRUD)
  * Todo 상세 조회
  * 오늘 / 일주일 / 전체 기간별 Todo 조회
* Study
  * 스터디 그룹 생성, 조회, 수정, 삭제 (CRUD)
  * 스터디 공유 Todo 생성, 조회, 수정, 삭제 (CRUD)
  * 스터디 기간 설정
  * 스터디 인원 제한 설정
  * 스터디 커뮤니티 별 실시간 채팅

<br>

### Todo

* todo 생성

  ![create_todo](assets/create_todo.gif)

* todo 수정 및 삭제

  ![update_and_delete_todo](assets/update_and_delete_todo.gif)

* todo week 조회

  ![week](assets/week.gif)

* todo all 조회

  ![plan_all](assets/plan_all.gif)

<br>

### Study

* 스터디 생성

  ![study_create](assets/study_create.gif)

* 스터디 리스트 조회

  ![study_index](assets/study_index.gif)

* 스터디 가입 신청

  ![study_join_plz](assets/study_join_plz.gif)

* 스터디 가입 수락

  ![study_accept](assets/study_accept.gif)

* 스터디 채팅

  ![chatting](assets/chatting.gif)

<br>

### Accounts

* 알림 메세지

  ![accounts_err](assets/accounts_err.gif)

* 특정 태그의 todo list 조회

  ![tag](assets/tag.gif)

<br>

## 프로젝트 후기

- 오채현
  - 기획에서 생각했던 것처럼 간단하지 않아서 프로젝트 구현에 예상보다 시간이 오래 걸렸다.
  - 화면을 구성하는 것은 금방 끝났지만 js를 통한 이벤트 발생과 비동기에서 조금 어려움을 겪었었다.
  - 기간 내에 구현하기 위해 조금은 비효율적으로 작성한 코드들을 추후에 수정을 해서 프로젝트를 개선 시키고 싶다.
- 류진숙
  - 플래너를 만들어보고 싶다는 생각이 있었는데, 좋은 팀원들과 만들 수 있어서 행복한 시간이었다. 
  - 처음으로 DOM조작을 통해 자바스크립트 코드를 여러개 직접 작성해보고, 부트스트랩을 이용하지 않고 css로만 화면구성을 진행하였다는 점이 매우 뿌듯했다.
- 이성인
  - 버그 테스트의 중요성을 새삼 깨달았습니다. 기능이라는 것이 톱니바퀴와 같아서 서로 맞물리면서 잘 돌아가야 하는데요. 그런데 저는 톱니 바퀴만 만들고 나는 기능 개발 다 했어!!! 라고 했던 부분들이 꽤 있었습니다. 그리고 이 과정은 기능 개발 만큼이나 많은 생각을 해야 했습니다.
  - 코딩이라는 것이 나의 생각을 컴퓨터에게 전달하는 과정이고, 꽃을 피운다는 건 열매를 맺기 전에 가장 중요한 활동이라고 한다면, 버그 테스트야 말로 코딩의 꽃이 아닐까? 생각을 했습니다.
- 이은진
  - 많은 것들을 경험해보고 부딪혀보려고 했는데 생각만큼 잘 되지 않았어서 내가 좀 더 실력을 갖춘 사람이 되어야겠다고 다짐했고 공부도 스스로 많이 하고 토이프로젝트도 혼자서 만들어 봐야겠다고 생각했습니다
- 이동근
  - 플래너, todo, 다이어리와 같은 기록 관련 서비스는 전혀 사용해본 경험이 없어서 구현에 있어서 좀 헤맸지만, 좋은 경험이었다.

<br>



### 제 입장(백엔드)에서 바라본 개발을 진행하면서 어려웠던 점

### Todos

#### 나열 기준

|           | 기존 |     플래너     |
| :-------: | :--: | :------------: |
| 나열 기준 |  pk  | 수행 예정 날짜 |

맨 처음으로 어떻게 구조를 가져올지 구상하면서 느꼈던 막막함은 기존에 모델링은 주로 제품이나 상품이 중심이었는데. 플래너는 시간이 중심이다는 점이었습니다. 다르다고 느꼈던 것이 기존에는 주로 PK값을 중심으로 생성된 순서대로 나열을 하였는데. 플래너 같은 경우 내가 **수행할 예정인 날짜**를 중심으로 나열이 필요했습니다. 

그 동안 프로젝트를 하면서 음식점, 댓글, 게시글, 제품 등 많은 CURD를 해 보았지만 항상 생성된 시간이 중요했고, 그래서 날짜는 항상 `auto_now_add=True`를 사용하여 나타내기만 했는데. 처음으로 사용자로 부터 날짜를 받아와서, 그 날짜를 중심으로 사용자에게 데이터를 보여줘야 했습니다. 어려운 문제는 아니었지만, 익숙하지 않은 새로운 구조라서 처음에는 많이 당황을 했습니다. 

#### week

플래너를 만들다 보니 이걸 주 단위로 보여주는 페이지가 필요했습니다. 그런데 여기서 발생한 문제가 만약 오늘이 2022년 12월 13일 화요일이라면 이틀 전인 11일 부터 17일까지를 보여줘야 했고, 15일이라면 4일 전부터 보여줘야 했습니다. 

이 문제를 해결하기 위해 찾아보니 요일을 숫자로 나타내 주는 함수가 있었습니다. 그리고 이 값을 바탕으로 일요일에 해당하는 날짜를 찾을 수 있었고 그 날짜를 기준으로 7일을 보여줌으로써 문제를 해결할 수 있었습니다. 

여기에 이번주 다음주의 값도 보여 줘야 했는데. 저는 이 문제를 주소창을 통해 0,1,2,-1,-2등을 받게 해서 0이면 이번주 1이면 다음주 -1이면 지난주를 보여줄수 있게 설계를 했습니다..

문제를 해결하고 기분좋게 프론트 친구에게 이게 이런식으로 변수화 해서 데이터 보낼줄께 라고 했는데. 프론트를 하는 친구는 다음주 지난주로 이동 할 때 비동기를 통해 구현을 하고 싶다고 했습니다. 음... 그러면 return 값만 JsonResponse으로 보내 주면 되겠네라고 생각을 했는데. 그렇게 하니까 처음에 화면을 불러올때 문제가 발생을 하였고, 이걸 해결하기 위해 week(동기)와 week(비동기)로 나누었고, 맨처음에는 무조건 동기로 된 페이지를 불러오게 하였고, 이 페이지에서 지난주로 가기는 다음주로 가기로 클릭을 하면 비동기 페이지를 불러오는 방식을 택했습니다. 



### Studies

#### index(스터디방 목록 페이지)

[planT index페이지](http://plan-t.site/studies/)

[깃허브 index HTML](https://github.com/sungin95/Final-project/blob/main/templates/studies/complete/study_index.html)

[깃허브 studies views.py](https://github.com/sungin95/Final-project/blob/main/studies/views.py)

목록을 내타낼때 카테고리, 검색, 페이지 네이션 3가지 종류로 나타냈습니다. 

이 셋은 모두 주소창에 띄는 입풋 값을 통하여 나타나게 됩니다. 그런데 무작정 이 셋을 넣고 보니 검색을 하면 카테고리가 사라지고 페이지 네이션을 누르면 검색과 카테고리가 사라지는 문제가 발생하였습니다. 

이 문제를 해결하기 위해서 우선 순서를 정했습니다. 

예를 들어 보통 카테고리를 클릭하는 순간은 새롭게 찾을 때이고, 검색을 한다면 현재 카테고리에서 정보를 찾을 거라고 생각했습니다. 그리고 페이지 네이션을 클릭할 때는 카테고리랑 검색내용이 유지 되어야 한다고 보았습니다. 

순서: 카테고리 > 검색 > 페이지네이션

순서를 정하고 나서는 HTML페이지에서 input값이 유지가 될 수 있도록 조치를 취할 필요가 있었습니다. 우선 검색할 때 현재 클릭한 카테고리가 유지가 되도록 만들기 위해 숨김 처리를 해서 사용자는 모르지만 해당 카테고리값을 다시 불러 올 수 있도록 설계를 했습니다. 

```html
<input type="text" name="tabmenu" value="{{category}}" style="display: none;">
```



페이지 네이션은 모두를 고려해 주기 위해 현재페이지에서 아래의 3개의 값을 다시 불러오도록 설계를 했습니다. 

```html
<a class="page-link" href="?page={{ page_number }}&search={{search}}&tabmenu={{category}}">{{ page_number }}</a>
```



마지막으로는 views.py 에서 해당 순서대로 코드를 추가 할 수 있도록 설계를 했습니다.

```python
def index(request):
    category = request.GET.get("tabmenu")

    # 카테고리
    if category is None or category == "on" or category == "None":
        category_studies = Study.objects.all().order_by("-pk")
    else:
        category_studies = Study.objects.filter(category=category).order_by("-pk")

    # 검색
    search = request.GET.get("search")
    if search is not None and search != "None":
        studies = Study.objects.all()
        search_lists = studies.filter(
            Q(title__icontains=search) | Q(desc__icontains=search)
        )
        category_studies = category_studies & search_lists
    # 페이지 네이션 코드
    page_number = request.GET.get("page")
    paginator = Paginator(category_studies, 8)
    page_list = paginator.get_page(page_number)

    context = {
        "category_studies": category_studies,
        "page_list": page_list,
        "category": category,
        "search": search,
    }

    return render(request, "studies/complete/study_index.html", context)
```



#### 스터디 가입신청, 수락과 거절(반장)

[깃허브 studies views.py](https://github.com/sungin95/Final-project/blob/main/studies/views.py)

258~385

스터디 가입과 수락을 만들때 가장 어려웠던건 어떻게 모델링을 짤 것인가 였습니다. 이때 생각이 난게 각 유저가 여러개의 스터디에 대하여 가입 신청을 할 수 있고, 스터디도 여러 유저를 받을 수 있다고 생각해 `ManyToManyField`를 사용하자 생각했습니다. 비슷한 모델로는 User간의 팔로우를 생각했고, 한쪽이 팔로우를 누르면 가입, 상대편도 맞팔을 해 주면 수락으로 만들면 되겠다고 생각을 했습니다. 

팔로우 개념으로 스터디 만듬

|        | 한쪽만 | 서로 |
| :----: | :----: | :--: |
| 팔로우 | 팔로우 | 맞팔 |
| 스터디 |  가입  | 수락 |

이걸 위해 `Study`에서 `participated`라는 가입 신청한 인원을 받는 필드를 만들고, `User`에서 `join_study`이라는 가입된 스터디 목록을 나타내는 필드를 만들었습니다. 예시를 들면

| Study - participated (가입신청) |      | User - join_study (수락) |
| :-----------------------------: | ---- | :----------------------: |
|             A(반장)             |      |         A(반장)          |
|             B(멤버)             |      |         B(멤버)          |
|           C(가입신청)           |      |   (C만 목록에서 보임)    |

위 표 처럼 반장은 자동으로 양쪽에 생성되도록 하고, B 처럼 가입신청후 수락까지 받으면 멤버, C처럼 가입 신청만 한 상태면 수락 목록에서만 보이도록 설계를 했습니다. 





#### info(가입페이지) & detail(멤버 활동 페이지)

스터디를 운영한다면 등록된 멤버만 사용이 가능해야 하니까 페이지를 둘로 나누어야 한다고 생각했습니다. 

우선 유저가 가입되기 전에 스터디를 소개하는 페이지가 필요하고, 유저가 가입되고 활동하는 페이지가 필요했습니다. 















